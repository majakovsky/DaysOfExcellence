### Тренировки по алгоритмам 1.0

В этом разделе я разобрал первую часть [тренировок по алгоритмам](https://yandex.ru/yaintern/algorithm-training_1)
В котором были разобраны такие лекции, как:

- Сложность, тестирование, особые случаи
- Линейный поиск
- Множества
- Словари и сортировка подсчётом
- Префиксные суммы и два указателя
- Бинарный поиск
- Сортировка событий
- Деревья



P.S. В этом разделе я не буду заниматься переписыванием или написанием кратких конспектов по лекциям.
В нём будет только мои решения практических задач, а также разбор заданий из лекций для 
закрепления и восстановления в памяти через какое-то N-ое время

_____________________________________________________________________________________________________________________________


### Задача №1

 Дана строка (в кодировке UTF-8). Найти самый часто встречающийся в ней символ. Если несколько символов встречаются одинакого часто, то можно вывести любой из них

 Вариант решения №1

 ```python
from collections import Counter

def search_max(input_string):
    # Подсчитываем количество встреч каждого символа в строке
    char_count = Counter(list)
    # Находим символ с наибольшим количеством встреч
    most_common = char_count.most_common(1)[0][0]
    return most_common

list = "1132531"
print("Самый часто встречающийся символ:", search_max(list))
```
Это мой вариант решения, в которм я решил использовать "Counter".
Также хотелось бы разобрать строку более подробно : 

```python
most_common = char_count.most_common(1)[0][0]
```

1. Параметр 1 указывает, что мы хотим получить только один наиболее часто встречающийся элемент.
2. [0]: Это индексация списка, который возвращает метод most_common(). Поскольку мы запросили только один наиболее часто встречающийся элемент, в этом списке будет только один кортеж, и мы обращаемся к нему по индексу 0.
3. [0]: После того как мы получили кортеж, содержащий наиболее часто встречающийся элемент и его количество, мы снова обращаемся к индексу 0, чтобы получить самый часто встречающийся элемент. Кортеж имеет форму (элемент, количество), и поэтому первый элемент кортежа содержит сам элемент.

 Вариант решения №2 (с лекции)

 ```python
s = input()
print(max(map(lambda x : (s.count(x), x), s))[1])
```

Вариант решения №3 (с лекции)

```python
s = input()
ans = ''
anscnt = 0
for i in range(len(s)):
    nowcnt = 0
    for j in range(len(s)):
        if s[i] == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = s[i]
        anscnt = nowcnt
print(ans)
```
Вариант решения №4 (с лекции)

```python
s = input()
ans = ''
anscnt = 0

for now in set(s): # перебор в множестве, составленных из символов строки 
    nowcnt = 0
    for j in range(len(s)):
        if now == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = now
        anscnt = nowcnt
print(ans)
```

В предыдущем решении были переборы несколько раз одного и того же. Поэтому данный способ лучше

Вариант решения №5
