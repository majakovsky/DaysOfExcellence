### Тренировки по алгоритмам 1.0

В этом разделе я разобрал первую часть [тренировок по алгоритмам](https://yandex.ru/yaintern/algorithm-training_1)
В котором были разобраны такие лекции, как:

- Сложность, тестирование, особые случаи
- Линейный поиск
- Множества
- Словари и сортировка подсчётом
- Префиксные суммы и два указателя
- Бинарный поиск
- Сортировка событий
- Деревья



P.S. В этом разделе я не буду заниматься переписыванием или написанием кратких конспектов по лекциям.
В нём будет только мои решения практических задач, а также разбор заданий из лекций для 
закрепления и восстановления в памяти через какое-то N-ое время

_____________________________________________________________________________________________________________________________


### Задача №1

 Дана строка (в кодировке UTF-8). Найти самый часто встречающийся в ней символ. Если несколько символов встречаются одинакого часто, то можно вывести любой из них

 Вариант решения №1

 ```python
from collections import Counter

def search_max(input_string):
    # Подсчитываем количество встреч каждого символа в строке
    char_count = Counter(list)
    # Находим символ с наибольшим количеством встреч
    most_common = char_count.most_common(1)[0][0]
    return most_common

list = "1132531"
print("Самый часто встречающийся символ:", search_max(list))
```
Это мой вариант решения, в которм я решил использовать "Counter".
Также хотелось бы разобрать строку более подробно : 

```python
most_common = char_count.most_common(1)[0][0]
```

1. Параметр 1 указывает, что мы хотим получить только один наиболее часто встречающийся элемент.
2. [0]: Это индексация списка, который возвращает метод most_common(). Поскольку мы запросили только один наиболее часто встречающийся элемент, в этом списке будет только один кортеж, и мы обращаемся к нему по индексу 0.
3. [0]: После того как мы получили кортеж, содержащий наиболее часто встречающийся элемент и его количество, мы снова обращаемся к индексу 0, чтобы получить самый часто встречающийся элемент. Кортеж имеет форму (элемент, количество), и поэтому первый элемент кортежа содержит сам элемент.

 Вариант решения №2 (с лекции)

 ```python
s = input()
print(max(map(lambda x : (s.count(x), x), s))[1])
```

Вариант решения №3 (с лекции)

```python
s = input()
ans = ''
anscnt = 0
for i in range(len(s)):
    nowcnt = 0
    for j in range(len(s)):
        if s[i] == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = s[i]
        anscnt = nowcnt
print(ans)
```
Вариант решения №4 (с лекции)

```python
s = input()
ans = ''
anscnt = 0

for now in set(s): # перебор в множестве, составленных из символов строки 
    nowcnt = 0
    for j in range(len(s)):
        if now == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = now
        anscnt = nowcnt
print(ans)
```

В предыдущем решении были переборы несколько раз одного и того же. Поэтому данный способ лучше

Вариант решения №5

```python
s = input()
ans = ''
anscnt = 0
dct = {} # создание словаря

for now in s:
    if now not in dct:
        dct[now] = 0
        dct[now] += 1
for key in dct:
    if dct[key] < anscnt:
        anscnt = dct[key]
        ans = key
print(ans)
```

Но и этот оказался не максимально улучшенный код(4в), поэтому заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающем с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающему с этим символом единицу.

Дальше мы начинаем рассматривать особые случаи. Например,
"сумма последовательности":

```python
seq = list(map(int, input().split()))
if len(seq) == 0:
  print(0)
else:
  seqsum = seq[0]
  for i in range(1, len(seq)):
     seqsum += seq[i]
  print(seqsum)
```
Давайте сравним то, что мы написали. Как мы можем увидеть, в первом случае мы сделали проверку, что являлось ошибкой. Она здесь лишняя, ведь второй, анологичный код, но без проверки - выведет абсолютно тоже самое. "Чем больше строк кода, чем больше вероятных ошибок в нем". Стараемся научиться использовать только то, что нужно в коде, да бы код был чище!

```python
seq = list(map(int, input().split()))
seqsum = 0
for i in range(len(seq)):
  seqsum += seg[i]
print(seqsum)
```

Теперь давайте посмотрим на "максимум последовательности"

```python
seq = list(map(int, input().split()))
seqmax = 0
for i in range(len(seq)):
  if seq[i] > seqmax:
    seqmax = seq[i]
print(seqmax)
```

Какая ошибка в этом коде? Мы не учли момент, если в последовательности будет числа отрицательные. В таком случае программа выведет "0". Поэтому давайте доработаем программу

```python
seq = list(map(int, input().split()))
if len(seq) == 0: # если последовательность пустая, то мы выводим 
  print('-inf') # минус бесконечность
else:
  seqmax = seq[0]
  for i in range(1, len(seq)):
    if seq[i] > seqmax:
      seqmax = seq[i]
  print(seqmax)
```

В данном случае проверка необходима, в отличие от предыдущего кода. Без нее наш код может сломаться. 


Тестирование - важное умение любого программиста 
Что нужно протестировать?

- тесты из условий (если есть)
- общие случаи
- особые случаи
 
